---
title: Pods - Triển khai spring boot container trên Kubernetes
date: '2020-12-10'
tags: ['api', 'rest api', 'kubernetes']
series: ['k8s-spring-boot']
draft: false
authors: ['thanhnb']
images: ['/static/images/ogps/k8s-springboot.png']
summary: 'Sample summary'
---

![Spring boot application với Kubernetes](/static/images/ogps/k8s-springboot.png)

<TOCInline toc={props.toc} asDisclosure />

## 1. Giới thiệu chung

Đây là buổi thứ hai trong series triển khai ứng dụng spring boot trên Kubernetes. Trong bài này thì mình cùng nhau tìm hiểu về `Pod`, cách đóng gói containers với `Pod` và sẽ đi qua những phần sau:

- Đóng gói ứng dụng Spring boot với Docker container.
- Tìm hiểu về cách tạo mới, triển khai `Pods` trên Kubernetes.
- Tìm hiểu về cách nhóm các `Pods` với `labels`.
- Tìm hiểu về vòng đời của `Pod`.

Các bạn có thể tham khảo source code [ở đây](https://github.com/nbthanh98/k8s-springboot-series.git) và checkout nhánh: `series/k8s-springboot/pod`.

## 2. Yêu cầu môi trường

Đầu tiên bạn cần cài [Docker](https://www.docker.com/), bạn có thể kiểm tra rằng `Docker` đã cài trên máy hay chưa bằng lệnh:

```shell
docker run hello-world

# Nếu mà show cái message như dưới đây thì đã cài Docker thành công rôi.
Hello from Docker!
This message shows that your installation appears to be working correctly.
```

Bạn cũng cần có môi trường local Kubernetes, bạn có thể sử dụng [Minikube](https://kubernetes.io/vi/docs/tasks/tools/install-minikube/) hoặc [MicroK8s](https://microk8s.io/tutorials) nhưng trong series này mình sử dụng `MicroK8s`. Bạn có thể kiểm tra môi trường Kubernetes bằng lệnh:

```shell
# Kiểm tra kubectl đã được cài hay chưa?, sử dụng lệnh:
kubectl cluster-info

Kubernetes control plane is running at https://192.168.1.123:16443

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.

# Kiểm tra trạng thái của các nodes, sử dụng lệnh:
kubectl get nodes

NAME   STATUS   ROLES    AGE   VERSION
nbt    Ready    <none>   9d    v1.25.4
```

## 3. Đóng gói Spring boot application với Docker

![Dockerfile, Docker image and Docker containers](/static/images/assets/dockerfile-dockerimage-container.png)

**Docker là gì?**

Docker giúp cho các Developer và Sysadmin để triển khai ứng dụng với container. Nó cho phép tạo các môi trường độc lập và tách biệt, khi cần triển khai ứng dụng trên môi trường nào thì chỉ cần pull Docker image của ứng dụng đó và tạo container thì ứng dụng của bạn sẽ được khơi chạy ngay lập tức.

**Tại sao lại sử dụng Docker?**

Vì Docker cho phép tạo ra các môi trường độc lập và tách biệt, điều này sẽ giúp nhất quán về môi trường khi triển khai ứng dụng lên nhiều môi trường khác nhau. Docker có cộng đồng người sử dụng lớn, có nhiều Docker image chất lượng được đóng góp từ cộng đồng và các docker image này cũng được fix lỗi và cập nhật thường xuyên.

**Triển khai Spring boot application với Docker**

1. **Tạo Dockerfile và build Docker image từ Dockerfile**

   Đầu tiên cần tạo `Dockerfile` bên trong `Dockerfile` là các lệnh để hướng dẫn Docker tạo Docker image. Ví dụ `Dockerfile` như file dưới đây:

   ```dockerfile
   FROM adoptopenjdk/openjdk11:latest
   WORKDIR /workspace
   COPY target/*-SNAPSHOT.jar /workspace/app.jar
   ENV TZ="Asia/Ho_Chi_Minh"
   EXPOSE 8080
   ENTRYPOINT ["java","-jar","/workspace/app.jar"]
   ```

   Dockerfile trên bao gồm các lệnh:

   - `FROM`: Lệnh này sẽ pull một Docker image ở đây là `adoptopenjdk/openjdk11:latest` để tạo ra một base image layer, các lệnh tiếp theo trong `Dockerfile` sẽ được thực thi trên base image layer này. `Dockerfile` bắt buộc phải bắt đầu từ `FROM`.

   - `WORKDIR`: Các lệnh tiếp theo trong `Dockerfile` sẽ được thực hiện trong folder mà lệnh `WORKDIR` định nghĩa, trường hợp này là folder `/workspace`.

   - `COPY`: Thực hiện copy file jar ở folder `target` vào folder `/workspace/` bên trong container.

   - `ENV`: Sử dụng để truyền biến môi trường vào bên trong container, trường hợp này là `TZ="Asia/Ho_Chi_Minh"`.

   - `EXPOSE`: Dùng để mô tả rằng ứng dụng sẽ chạy ở port bao nhiêu, trường hợp này là port `8080`.

   - `ENTRYPOINT`: Khi container start thì lênh bên trong `ENTRYPOINT` sẽ được thực hiện, trường hợp này là chạy file jar.

   Bây giờ bạn có thể build docker image bằng lệnh sau:

   ```shell
   docker build -t k8s-springboot-series:latest -f Dockerfile .

   Sending build context to Docker daemon  18.05MB
   Step 1/6 : FROM adoptopenjdk/openjdk11:latest
    ---> 49877461f3c7
   Step 2/6 : WORKDIR /workspace
    ---> Running in af4cc5d9485b
   Removing intermediate container af4cc5d9485b
    ---> 93bad477e120
   Step 3/6 : COPY target/*-SNAPSHOT.jar /workspace/app.jar
    ---> 08b67e5bfac9
   Step 4/6 : ENV TZ="Asia/Ho_Chi_Minh"
    ---> Running in 87c88aba3e8b
   Removing intermediate container 87c88aba3e8b
    ---> 8482d4c26ef8
   Step 5/6 : EXPOSE 8080
    ---> Running in 19fcfb82ca20
   Removing intermediate container 19fcfb82ca20
    ---> cc97ad8d0a21
   Step 6/6 : ENTRYPOINT ["java","-jar","/workspace/app.jar"]
    ---> Running in 2d87a166c58a
   Removing intermediate container 2d87a166c58a
    ---> 1403dab63194
   Successfully built 1403dab63194
   Successfully tagged k8s-springboot-series:latest
   ```

   Kiểm tra docker image bằng lệnh:

   ```shell
   docker images

   REPOSITORY                TAG       IMAGE ID       CREATED         SIZE
   k8s-springboot-series     latest    1403dab63194   7 minutes ago   456MB
   ```

2. **Tạo docker container từ docker image**

   Sau bước build docker image từ Dockerfile trên thì bạn đã có một docker image là `k8s-springboot-series:latest`, giờ bạn có thể tạo một hoặc nhiều docker container từ docker image vừa build bằng lệnh sau:

   ```shell
   docker run --name k8s-springboot-series -d -p 8080:8080 k8s-springboot-series:latest
   ```

   Kiểm tra docker container bằng lệnh:

   ```shell
   docker ps

   CONTAINER ID   IMAGE                          COMMAND                  CREATED         STATUS         PORTS                                       NAMES
   14330e1c04cb   k8s-springboot-series:latest   "java -jar /workspac…"   3 seconds ago   Up 2 seconds   0.0.0.0:8080->8080/tcp, :::8080->8080/tcp   k8s-springboot-series
   ```

3. **Dùng [Postman](https://www.postman.com/downloads/) gọi thử các API**

   **API tạo mới Student:**

   Endpoint: `/api/students`, method `POST` và Request body:

   ```json
   {
     "fullName": "NGUYEN BA THANH",
     "dateOfBirth": "29/04/1998",
     "hometown": "HA DONG, HA NOI",
     "gender": "MALE"
   }
   ```

   ![API tạo mới Student với Postman](/static/images/assets/call-api-create-student.png)

   **API lấy danh sách Student:**

   Endpoint: `/api/students`, method `GET`.

   ![API lấy danh sách Student với Postman](/static/images/assets/get-all-student.png)

## 4. Đóng gói container với Pods và triển khai trên Kubernetes

Ở phần 3 chúng ta đã đóng gói Spring boot application với Docker, trong phần này thì chúng ta sẽ tìm hiểu cách đóng gói containers với `Pods` trong Kubernetes.

![Pods kubernetes](/static/images/assets/pod-kubernetes.png)

**Pods là gì?**

Đối với Docker thì containers là đơn vị nhỏ nhất, còn trong Kubernetes thì `Pods` là object nhỏ nhất có thể triển khai trên Kubernetes. Kubernetes thì không chạy container một cách trực tiếp, thay vì đó thì Kubernetes sẽ đóng gói một hoặc nhiều containers vào một object được gọi là `Pod` và triển khải trên Kubernetes. Các containers bên trong `Pod` thì chia sẻ network và storage resources:

- `Network`: Các containers bên trong `Pod` có thể giao tiếp với nhau dễ dàng thông qua `localhost:<PORT_CONTAINER>`.
- `Storage`: Các containers bên trong `Pod` có thể chia sẻ với nhau cùng volumes.

**Tại sao Kubernetes không chạy containers trực tiếp?**

Thêm nội dung ở đây

**Cách tạo Pod**

- Tạo Pod bằng cách dùng lệnh

- Tạo Pod bằng manifests file

## 5. Tổng kết
